<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xlink="http://www.w3.org/1999/xlink" 
    exclude-result-prefixes="#all"
    version="2.0">

<!-- JCBG-1371 (automated link checking):
     This XSL collects all the xlink:href attribute values, which should be URLs. 
     It then generates an ant file to list these values, flagging the invalid ones.
     main-build.xml invokes this stylesheet; it also invokes ant on the generated file.     
-->

<!-- Declare parameter so that I can use it later. Value should be set already. -->
<xsl:param name="module.dir"/>

<!-- We do two passes.
	
	First pass: Creates a variable to hold elements that have an xlink:href attribute and do not have an xlink:role="generated" attribute.
	(Items with such an xlink:role attribute are generated by the build, so the link is known to be valid. 
	Plus, the script cannot check such URLs anyway.)
	 
	Second pass: Creates the ant file. Gets a list of unique URLs and writes the ant code to test those URLs. 
-->
	
<!-- First pass -->	
	<xsl:template match="/" >
		<xsl:variable name="pass1">
			<xsl:apply-templates select="//*[@xlink:href and not(@xlink:role = 'generated')]">
				<xsl:sort select="@xlink:href"/>
			</xsl:apply-templates>
		</xsl:variable>
		<xsl:apply-templates select="$pass1" mode="pass2"/>
	</xsl:template>
	
<!-- Second pass -->
    <xsl:template match="/" mode="pass2">
 
      <!-- Content for the ant file -->
      <project>

	<!-- JCBG-2043: setproxy now done in main-build.xml. Keyword (to help when searching for this line): planid -->
           
	<xsl:comment>Check the &lt;http&gt; condition. If a URL does not return a valid response, display a message.
	(By default, a valid response is a value less than 400.)</xsl:comment> 
	
	<!-- Content for the ant file -->                            
	<trycatch><!-- Use trycatch to keep issues encountered during the ant run on the generated file from failing the doc build.-->
	  <try>

	<!-- Get a list of unique URLs and use the URLs in the generated ant file content. -->
	<xsl:for-each select="distinct-values(//@xlink:href)">

    <xsl:choose>
    	
      
      <!-- Skip URLs that start with "https"; the <http> condition cannot check them. -->
    	<xsl:when test="starts-with(normalize-space(current()),'https')">
	<!-- Content for the ant file -->
	<echo>URL not checked (starts with "https"/requires login): <xsl:value-of select="."/></echo>
      </xsl:when>
      
      <!-- Skip mojo.motive.com URLs; the <http> condition cannot check them. -->
      <xsl:when test="contains(current(),'mojo.motive.com')">
	<!-- Content for the ant file -->
	<echo>URL not checked (mojo requires login): <xsl:value-of select="."/></echo>
      </xsl:when>

      <!-- Skip Belgium URLs; the <http> condition cannot check them. -->
      <xsl:when test="contains(current(),'-1.be.alcatel')">
	<!-- Content for the ant file -->
	<echo>URL not checked (unable to check *-1.be.alcatel-lucent.com URLs): <xsl:value-of select="."/></echo>
      </xsl:when>
		
      <!-- Skip URLs linking to embedded files, they throw errors but will work after build  -->
    	<xsl:when test="starts-with(normalize-space(current()),'embed/')">
	<!-- Content for the ant file -->
	<echo>URL not checked (links to embedded file available after build): <xsl:value-of select="."/></echo>
      </xsl:when>	
    	
      <!-- Skip URLs with mailto: prefix, as we can't validate those  -->
    	<xsl:when test="starts-with(normalize-space(current()),'mailto:')">
	<!-- Content for the ant file -->
	<echo>URL not checked (looks like a valid mailto, but I can't tell if a mail address is valid): <xsl:value-of select="."/></echo>
      </xsl:when>	
		
      <!-- Skip URLs that start with / as they are relative links and don't work in http condition; they cause it to error out  -->
    	<xsl:when test="starts-with(normalize-space(current()),'/')">
	<!-- Content for the ant file -->
	<echo>URL not checked (starts with /; test it manually in your generated document output): <xsl:value-of select="."/></echo>
      </xsl:when>	
    	
      <!-- Skip URLs that start with . as they are relative links; they don't cause a failure, but we can offer a better msg  -->
    	<xsl:when test="starts-with(normalize-space(current()),'.')">
	<!-- Content for the ant file -->
	<echo>URL not checked (relative link; test it manually in your generated document output): <xsl:value-of select="."/></echo>
      </xsl:when>	
		
      <!-- JCBG-1649: http condition returns SUCCESS even for "Topic not found" IC pages so download/search pubs.motive.com pages. -->
      <xsl:when test="contains(current(),'pubs.motive.com')">
	<var name="timestamp" value="" unset="true"/> <!-- antcontrib task -->
	<tstamp><format property="timestamp" pattern="hh:mm:ss aa"/></tstamp>

      	<xsl:variable name="original-url" select="."/>
      	<echo>(${timestamp}) Checking URL: <xsl:value-of select="$original-url"/></echo>
      	
	<!-- Running the "Topic not found" check does not work under Maven, as is done in server builds.
	     So, skip that check in a server build, telling the writer to run the build locally through Oxygen.
	     (If planid-set is set, the build is a server build.) -->
	<if>
	  <isset property="planid-set"/>
	  <then>
	    <echo>URL not checked (pubs.motive.com infocenter URLs cannot be checked in server builds or in local builds that use Maven (mvn); 
	    build the doc in Oxygen or using ant--do NOT use the mvn CLI--and search for "Topic not found"): <xsl:value-of select="."/></echo>
	  </then>
	  <else>
	    <xsl:choose>
	      <!-- If URL contains "index.jsp" the get task gets a frameset; 
		   change "index.jsp?topic=" to "topic" and change remaining "%2F" chars to "/" to get the expected page. -->      	
	      <xsl:when test="contains(current(),'index.jsp')">
		<xsl:variable name="tmp-url" select="replace($original-url, 'index.jsp\?topic=', 'topic')"/>
		<xsl:variable name="url-to-get" select="replace($tmp-url, '%2F', '/')"/>
		<get src="{$url-to-get}" dest="tmp.html"/>
	      </xsl:when>
	      <!-- URL does not contain "index.jsp" so just get it as is. -->
	      <xsl:otherwise>
		<xsl:variable name="url-to-get" select="."/>      			
		<get src="{$url-to-get}" dest="tmp.html"/>
	      </xsl:otherwise>
	    </xsl:choose>

	    <if>
	      <resourcecontains resource="tmp.html" substring="Topic not found"/>
	      <then>
		<echo>[check-urls WARNING] =====> Invalid URL: <xsl:value-of select="$original-url"/> (Topic not found)</echo>
		<property name="invalidURL" value="1"/>
	      </then>
	    </if>
	    <delete file="tmp.html"/>
	  </else>
	</if>

      </xsl:when>

      <!-- JCBG-2041: Detect and warn about empty href values -->
      <xsl:when test="string-length(normalize-space(current()))=0">
	<!-- Content for the ant file -->
	<var name="timestamp" value="" unset="true"/> <!-- antcontrib task -->
	<tstamp><format property="timestamp" pattern="hh:mm:ss aa"/></tstamp>
	<echo>(${timestamp}) Checking URL: <xsl:value-of select="."/></echo>
	<echo>[check-urls WARNING] =====> Invalid URL: <xsl:value-of select="."/> (No URL to check. Look for an empty href value in your source or in a referenced glossary term.)</echo>
	<property name="invalidURL" value="1"/>
      </xsl:when>

      <!-- URLs that do not start with a protocol and don't match other cases
    	   note that this test should not come before any others, so that all other exceptions can have their own messages 
    	   
    	   Adding this because without it, URLs that lack a protocol get tested by ant's http condition and not only fail, they
    	   cause the whole checking process to stop in its tracks. Instead, if no http:// prefix, add one and test THAT, and then report 
    	   one of two kinds of failure: 
    	     a) the URL works if you add http://, so you need to add that 
    	     b) the URL doesn't work with http://, so either it's bad, or you intentionally used a relative URL and I can't test that. 
   	   Note that this doesn't test any other protocols like mailto: or file:/// but the user should be able to figure those out.
      -->
    	    
    	<xsl:when test="not(starts-with(normalize-space(current()),'http://')) and not(starts-with(normalize-space(current()),'file://'))">
	<!-- Content for the ant file -->
	<var name="timestamp" value="" unset="true"/> <!-- antcontrib task -->
	<tstamp><format property="timestamp" pattern="hh:mm:ss aa"/></tstamp>
	<echo>The URL <xsl:value-of select="normalize-space(.)"/> does not start with http; adding http and testing:</echo>
      	<echo>(${timestamp}) Checking URL: <xsl:value-of select="concat('http://',normalize-space(.))"/></echo>
	<if>
	  <not><http url="http://{.}"/></not>
	  <then>
	    <echo>[check-urls WARNING] =====> Invalid URL: <xsl:value-of select="concat('http://',.)"/></echo>
	  	<echo>NOTE: If this is a relative URL, test it manually in your generated document output.</echo>
	    <property name="invalidURL" value="1"/>
	  </then>
	  <else>
	    <echo>[check-urls WARNING] =====> Invalid URL: <xsl:value-of select="."/>: This URL would be fine if you prefixed it with 'http://'</echo>
	    <property name="invalidURL" value="1"/>
	  </else>
	</if>
      </xsl:when>
   

      <!-- For all other URLs, check the <http> condition.
	   For the URLs that fail: Display them and set the invalidURL property. -->
      <xsl:otherwise>
	<!-- Content for the ant file -->
	<var name="timestamp" value="" unset="true"/> <!-- antcontrib task -->
	<tstamp><format property="timestamp" pattern="hh:mm:ss aa"/></tstamp>
	<echo>(${timestamp}) Checking URL: <xsl:value-of select="."/></echo>
	<if>
	  <not><http url="{.}"/></not>
	  <then>
	    <echo>[check-urls WARNING] =====> Invalid URL: <xsl:value-of select="."/></echo>
	    <property name="invalidURL" value="1"/>
	  </then>
	</if>
      </xsl:otherwise>
    </xsl:choose>                
                 
  </xsl:for-each>

  <!-- Content for the ant file -->                    
</try>
<catch><!-- ant failed somewhere in the generated file. Set invalidURL so that you can display tips text. -->
  <property name="invalidURL" value="1"/>
  <echo>
[check-urls WARNING] =====> Invalid URL in or near: <xsl:value-of select="."/>. 
That URL actually caused the checker to fail. 
Consider BOTH the "Checking URL" value and the "Invalid URL" value to determine the issue.
Does the URL have unexpected characters?</echo>
  <!-- Removed this statement 10/22/14, it is no longer true, we no longer test non-protocol URLS: The last URL mentioned above 
       might be missing a protocol, such as 'http://', 'file://', or 'mailto:'. -->
  
</catch>
</trycatch>

<if>
  <isset property="invalidURL"/>
  <then>
    <!-- Create a flag file. Send a notification email (from module2build.xml) if the file exists.-->
    <touch file="{$module.dir}/target/found.invalid.urls.flag"/>
    
    <echo><!-- Explain that invalid URLs were found and give some tips. -->
Found one or more invalid URLs. See the URLs listed above; they are preceded by '=====> Invalid URL:'.
This check tries URLs listed as xlink:href values in your XML source that do not start with 'https'.
===== Multiple occurrences
* Check your document for multiple occurrences of each invalid URL.
===== Common reasons that a URL is flagged as invalid 
* The URL uses 'pubs' instead of 'pubs.motive.com'.
* The URL does not include a protocol ('http://', 'file://', or 'mailto:'). 
===== Valid URL is flagged as invalid
* Some URLs that do work in a browser are flagged as invalid.
* URLs to an infocenter that is being refreshed are flagged as invalid because the infocenter is not accessible during the refresh.
    </echo>
  </then>
</if>


</project>
    
    </xsl:template>

<!-- The built-in template for attribute nodes is a no-op, so add the following template to pass the attributes down from pass1 to pass2. -->
	<xsl:template match='*|@*'>
		<xsl:copy>
			<xsl:apply-templates select='node()|@*'/>
		</xsl:copy>
	</xsl:template>
		
</xsl:stylesheet>